"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QnAMakerDialog = void 0;
/**
 * @module botbuilder-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const adaptive_expressions_1 = require("adaptive-expressions");
const botbuilder_core_1 = require("botbuilder-core");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const _1 = require("./");
const qnaCardBuilder_1 = require("./qnaCardBuilder");
const qnamaker_interfaces_1 = require("./qnamaker-interfaces");
const qnamaker_utils_1 = require("./qnamaker-utils");
class QnAMakerDialogActivityConverter {
    convert(value) {
        if (typeof value === 'string') {
            return new qnamaker_utils_1.BindToActivity(botbuilder_core_1.MessageFactory.text(value));
        }
        return value;
    }
}
/**
 * A dialog that supports multi-step and adaptive-learning QnA Maker services.
 *
 * @summary
 * An instance of this class targets a specific QnA Maker knowledge base.
 * It supports knowledge bases that include follow-up prompt and active learning features.
 * The dialog will also present user with appropriate multi-turn prompt or active learning options.
 */
class QnAMakerDialog extends botbuilder_dialogs_1.WaterfallDialog {
    /**
     * Initializes a new instance of the [QnAMakerDialog](xref:QnAMakerDialog) class.
     *
     * @param {string} knowledgeBaseId The ID of the QnA Maker knowledge base to query.
     * @param {string} endpointKey The QnA Maker endpoint key to use to query the knowledge base.
     * @param {string} hostname The QnA Maker host URL for the knowledge base, starting with "https://" and ending with "/qnamaker".
     * @param {string} noAnswer (Optional) The activity to send the user when QnA Maker does not find an answer.
     * @param {number} threshold (Optional) The threshold above which to treat answers found from the knowledgebase as a match.
     * @param {string} activeLearningCardTitle (Optional) The card title to use when showing active learning options to the user, if active learning is enabled.
     * @param {string} cardNoMatchText (Optional) The button text to use with active learning options, allowing a user to indicate none of the options are applicable.
     * @param {number} top (Optional) Maximum number of answers to return from the knowledge base.
     * @param {Activity} cardNoMatchResponse (Optional) The activity to send the user if they select the no match option on an active learning card.
     * @param {QnAMakerMetadata[]} strictFilters (Optional) QnA Maker metadata with which to filter or boost queries to the knowledge base; or null to apply none.
     * @param {string} dialogId (Optional) Id of the created dialog. Default is 'QnAMakerDialog'.
     * @param {string} strictFiltersJoinOperator join operator for strict filters
     */
    constructor(knowledgeBaseId, endpointKey, hostname, noAnswer, threshold, activeLearningCardTitle, cardNoMatchText, top, cardNoMatchResponse, strictFilters, dialogId = 'QnAMakerDialog', strictFiltersJoinOperator) {
        super(dialogId);
        this.strictFiltersJoinOperator = strictFiltersJoinOperator;
        // state and step value key constants
        /**
         * The path for storing and retrieving QnA Maker context data.
         *
         * @summary
         * This represents context about the current or previous call to QnA Maker.
         * It is stored within the current step's [WaterfallStepContext](xref:botbuilder-dialogs.WaterfallStepContext).
         * It supports QnA Maker's follow-up prompt and active learning features.
         */
        this.qnAContextData = 'previousContextData';
        /**
         * The path for storing and retrieving the previous question ID.
         *
         * @summary
         * This represents the QnA question ID from the previous turn.
         * It is stored within the current step's [WaterfallStepContext](xref:botbuilder-dialogs.WaterfallStepContext).
         * It supports QnA Maker's follow-up prompt and active learning features.
         */
        this.previousQnAId = 'previousQnAId';
        /**
         * The path for storing and retrieving the options for this instance of the dialog.
         *
         * @summary
         * This includes the options with which the dialog was started and options expected by the QnA Maker service.
         * It is stored within the current step's [WaterfallStepContext](xref:botbuilder-dialogs.WaterfallStepContext).
         * It supports QnA Maker and the dialog system.
         */
        this.options = 'options';
        // Dialog options parameters
        /**
         * The default threshold for answers returned, based on score.
         */
        this.defaultThreshold = 0.3;
        /**
         * The default maximum number of answers to be returned for the question.
         */
        this.defaultTopN = 3;
        this.currentQuery = 'currentQuery';
        this.qnAData = 'qnaData';
        this.defaultNoAnswer = 'No QnAMaker answers found.';
        // Card parameters
        this.defaultCardTitle = 'Did you mean:';
        this.defaultCardNoMatchText = 'None of the above.';
        this.defaultCardNoMatchResponse = 'Thanks for the feedback.';
        /**
         * Gets or sets the threshold for answers returned, based on score.
         */
        this.threshold = new adaptive_expressions_1.NumberExpression(this.defaultThreshold);
        /**
         * Gets or sets the maximum number of answers to return from the knowledge base.
         */
        this.top = new adaptive_expressions_1.IntExpression(this.defaultTopN);
        /**
         * Gets or sets the template to send to the user when QnA Maker does not find an answer.
         */
        this.noAnswer = new qnamaker_utils_1.BindToActivity(botbuilder_core_1.MessageFactory.text(this.defaultNoAnswer));
        /**
         * Gets or sets the template to send to the user if they select the no match option on an
         * active learning card.
         */
        this.cardNoMatchResponse = new qnamaker_utils_1.BindToActivity(botbuilder_core_1.MessageFactory.text(this.defaultCardNoMatchResponse));
        /**
         * Gets or sets the flag to determine if personal information should be logged in telemetry.
         *
         * @summary
         * Defauls to a value of `=settings.telemetry.logPersonalInformation`, which retrieves
         * `logPersonalInformation` flag from settings.
         */
        this.logPersonalInformation = new adaptive_expressions_1.BoolExpression('=settings.telemetry.logPersonalInformation');
        /**
         * Gets or sets a value indicating whether gets or sets environment of knowledgebase to be called.
         */
        this.isTest = false;
        /**
         * Gets or sets the QnA Maker ranker type to use.
         */
        this.rankerType = new adaptive_expressions_1.EnumExpression(qnamaker_interfaces_1.RankerTypes.default);
        if (knowledgeBaseId) {
            this.knowledgeBaseId = new adaptive_expressions_1.StringExpression(knowledgeBaseId);
        }
        if (endpointKey) {
            this.endpointKey = new adaptive_expressions_1.StringExpression(endpointKey);
        }
        if (hostname) {
            this.hostname = new adaptive_expressions_1.StringExpression(hostname);
        }
        if (threshold) {
            this.threshold = new adaptive_expressions_1.NumberExpression(threshold);
        }
        if (top) {
            this.top = new adaptive_expressions_1.IntExpression(top);
        }
        if (activeLearningCardTitle) {
            this.activeLearningCardTitle = new adaptive_expressions_1.StringExpression(this.defaultCardTitle);
        }
        if (cardNoMatchText) {
            this.cardNoMatchText = new adaptive_expressions_1.StringExpression(cardNoMatchText);
        }
        if (strictFilters) {
            this.strictFilters = new adaptive_expressions_1.ArrayExpression(strictFilters);
        }
        if (noAnswer) {
            this.noAnswer = new qnamaker_utils_1.BindToActivity(noAnswer);
        }
        this.cardNoMatchResponse = new qnamaker_utils_1.BindToActivity(cardNoMatchResponse !== null && cardNoMatchResponse !== void 0 ? cardNoMatchResponse : botbuilder_core_1.MessageFactory.text(this.defaultCardNoMatchResponse));
        this.addStep(this.callGenerateAnswer.bind(this));
        this.addStep(this.callTrain.bind(this));
        this.addStep(this.checkForMultiTurnPrompt.bind(this));
        this.addStep(this.displayQnAResult.bind(this));
    }
    getConverter(property) {
        switch (property) {
            case 'knowledgeBaseId':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'hostname':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'endpointKey':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'threshold':
                return new adaptive_expressions_1.NumberExpressionConverter();
            case 'top':
                return new adaptive_expressions_1.IntExpressionConverter();
            case 'noAnswer':
                return new QnAMakerDialogActivityConverter();
            case 'activeLearningCardTitle':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'cardNoMatchText':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'cardNoMatchResponse':
                return new QnAMakerDialogActivityConverter();
            case 'strictFilters':
                return new adaptive_expressions_1.ArrayExpressionConverter();
            case 'logPersonalInformation':
                return new adaptive_expressions_1.BoolExpressionConverter();
            case 'rankerType':
                return new adaptive_expressions_1.EnumExpressionConverter(qnamaker_interfaces_1.RankerTypes);
            default:
                return super.getConverter(property);
        }
    }
    /**
     * Called when the dialog is started and pushed onto the dialog stack.
     *
     * @summary
     * If the task is successful, the result indicates whether the dialog is still
     * active after the turn has been processed by the dialog.
     *
     * You can use the [options](#options) parameter to include the QnA Maker context data,
     * which represents context from the previous query. To do so, the value should include a
     * `context` property of type [QnAResponseContext](#QnAResponseContext).
     *
     * @param {DialogContext} dc The [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @param {object} options (Optional) Initial information to pass to the dialog.
     * @returns {Promise<DialogTurnResult>} A promise resolving to the turn result
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    beginDialog(dc, options) {
        const _super = Object.create(null, {
            beginDialog: { get: () => super.beginDialog }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!dc) {
                throw new Error('Missing DialogContext');
            }
            if (dc.context.activity.type != botbuilder_core_1.ActivityTypes.Message) {
                return dc.endDialog();
            }
            const dialogOptions = {
                qnaDialogResponseOptions: yield this.getQnAResponseOptions(dc),
                qnaMakerOptions: yield this.getQnAMakerOptions(dc),
            };
            if (options) {
                Object.assign(dialogOptions, options);
            }
            return yield _super.beginDialog.call(this, dc, dialogOptions);
        });
    }
    // Gets the options for the QnA Maker client that the dialog will use to query the knowledge base.
    // If the task is successful, the result contains the QnA Maker options to use.
    getQnAMakerOptions(dc) {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function* () {
            return {
                scoreThreshold: (_b = (_a = this.threshold) === null || _a === void 0 ? void 0 : _a.getValue(dc.state)) !== null && _b !== void 0 ? _b : this.defaultThreshold,
                strictFilters: (_c = this.strictFilters) === null || _c === void 0 ? void 0 : _c.getValue(dc.state),
                top: (_e = (_d = this.top) === null || _d === void 0 ? void 0 : _d.getValue(dc.state)) !== null && _e !== void 0 ? _e : this.defaultTopN,
                qnaId: 0,
                rankerType: (_g = (_f = this.rankerType) === null || _f === void 0 ? void 0 : _f.getValue(dc.state)) !== null && _g !== void 0 ? _g : qnamaker_interfaces_1.RankerTypes.default,
                isTest: this.isTest,
                strictFiltersJoinOperator: this.strictFiltersJoinOperator,
            };
        });
    }
    // Gets the options the dialog will use to display query results to the user.
    // If the task is successful, the result contains the response options to use.
    getQnAResponseOptions(dc) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            return {
                activeLearningCardTitle: (_b = (_a = this.activeLearningCardTitle) === null || _a === void 0 ? void 0 : _a.getValue(dc.state)) !== null && _b !== void 0 ? _b : this.defaultCardTitle,
                cardNoMatchResponse: this.cardNoMatchResponse && (yield this.cardNoMatchResponse.bind(dc, dc.state)),
                cardNoMatchText: (_d = (_c = this.cardNoMatchText) === null || _c === void 0 ? void 0 : _c.getValue(dc.state)) !== null && _d !== void 0 ? _d : this.defaultCardNoMatchText,
                noAnswer: yield ((_e = this.noAnswer) === null || _e === void 0 ? void 0 : _e.bind(dc, dc.state)),
            };
        });
    }
    // Queries the knowledgebase and either passes result to the next step or constructs and displays an active learning card
    // if active learning is enabled and multiple score close answers are returned.
    callGenerateAnswer(step) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            dialogOptions.qnaMakerOptions.qnaId = 0;
            dialogOptions.qnaMakerOptions.context = { previousQnAId: 0, previousUserQuery: '' };
            step.values[this.currentQuery] = step.context.activity.text;
            const previousContextData = step.activeDialog.state[this.qnAContextData] || {};
            let previousQnAId = step.activeDialog.state[this.previousQnAId] || 0;
            if (previousQnAId > 0) {
                dialogOptions.qnaMakerOptions.context = { previousQnAId: previousQnAId, previousUserQuery: '' };
                if (previousContextData[step.context.activity.text]) {
                    dialogOptions.qnaMakerOptions.qnaId = previousContextData[step.context.activity.text];
                }
            }
            const qna = yield this.getQnAClient(step);
            const response = yield qna.getAnswersRaw(step.context, dialogOptions.qnaMakerOptions);
            const qnaResponse = {
                activeLearningEnabled: response.activeLearningEnabled,
                answers: response.answers,
            };
            previousQnAId = -1;
            step.activeDialog.state[this.previousQnAId] = previousQnAId;
            const isActiveLearningEnabled = qnaResponse.activeLearningEnabled;
            step.values[this.qnAData] = response.answers;
            if (qnaResponse.answers.length > 0 &&
                qnaResponse.answers[0].score <= qnamaker_utils_1.ActiveLearningUtils.MaximumScoreForLowScoreVariation / 100) {
                qnaResponse.answers = qna.getLowScoreVariation(qnaResponse.answers);
                if (isActiveLearningEnabled && ((_a = qnaResponse.answers) === null || _a === void 0 ? void 0 : _a.length) > 1) {
                    const suggestedQuestions = [];
                    qnaResponse.answers.forEach((answer) => {
                        suggestedQuestions.push(answer.questions[0]);
                    });
                    const message = qnaCardBuilder_1.QnACardBuilder.getSuggestionsCard(suggestedQuestions, dialogOptions.qnaDialogResponseOptions.activeLearningCardTitle, dialogOptions.qnaDialogResponseOptions.cardNoMatchText);
                    yield step.context.sendActivity(message);
                    step.activeDialog.state[this.options] = dialogOptions;
                    return botbuilder_dialogs_1.Dialog.EndOfTurn;
                }
            }
            const result = [];
            if (((_b = response.answers) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                result.push(response.answers[0]);
            }
            step.values[this.qnAData] = result;
            step.activeDialog.state[this.options] = dialogOptions;
            return yield step.next(result);
        });
    }
    // If active learning options were displayed in the previous step and the user has selected an option other
    // than 'no match' then the training API is called, passing the user's chosen question back to the knowledgebase.
    // If no active learning options were displayed in the previous step, the incoming result is immediately passed to the next step.
    callTrain(step) {
        const _super = Object.create(null, {
            runStep: { get: () => super.runStep }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            const trainResponses = step.values[this.qnAData];
            const currentQuery = step.values[this.currentQuery];
            const reply = step.context.activity.text;
            if ((trainResponses === null || trainResponses === void 0 ? void 0 : trainResponses.length) > 1) {
                const qnaResult = trainResponses.filter((r) => r.questions[0] == reply);
                if ((qnaResult === null || qnaResult === void 0 ? void 0 : qnaResult.length) > 0) {
                    const results = [];
                    results.push(qnaResult[0]);
                    step.values[this.qnAData] = results;
                    const records = [];
                    records.push({
                        userId: step.context.activity.id,
                        userQuestion: currentQuery,
                        qnaId: qnaResult[0].id.toString(),
                    });
                    const feedbackRecords = { feedbackRecords: records };
                    const qnaClient = yield this.getQnAClient(step);
                    yield qnaClient.callTrainAsync(feedbackRecords);
                    return yield step.next(qnaResult);
                }
                else if (reply == dialogOptions.qnaDialogResponseOptions.cardNoMatchText) {
                    const activity = dialogOptions.qnaDialogResponseOptions.cardNoMatchResponse;
                    yield step.context.sendActivity(activity || this.defaultCardNoMatchResponse);
                    return step.endDialog();
                }
                else {
                    return yield _super.runStep.call(this, step, 0, botbuilder_dialogs_1.DialogReason.beginCalled);
                }
            }
            return yield step.next(step.result);
        });
    }
    // If multi turn prompts are included with the answer returned from the knowledgebase, this step constructs
    // and sends an activity with a hero card displaying the answer and the multi turn prompt options.
    // If no multi turn prompts exist then the result incoming result is passed to the next step.
    checkForMultiTurnPrompt(step) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            const response = step.result;
            if ((response === null || response === void 0 ? void 0 : response.length) > 0) {
                const answer = response[0];
                if (((_b = (_a = answer === null || answer === void 0 ? void 0 : answer.context) === null || _a === void 0 ? void 0 : _a.prompts) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                    const previousContextData = {};
                    answer.context.prompts.forEach((prompt) => {
                        previousContextData[prompt.displayText] = prompt.qnaId;
                    });
                    step.activeDialog.state[this.qnAContextData] = previousContextData;
                    step.activeDialog.state[this.previousQnAId] = answer.id;
                    step.activeDialog.state[this.options] = dialogOptions;
                    const message = qnaCardBuilder_1.QnACardBuilder.getQnAPromptsCard(answer);
                    yield step.context.sendActivity(message);
                    return botbuilder_dialogs_1.Dialog.EndOfTurn;
                }
            }
            return step.next(step.result);
        });
    }
    /**
     * Displays an appropriate response based on the incoming result to the user.If an answer has been identified it
     * is sent to the user. Alternatively, if no answer has been identified or the user has indicated 'no match' on an
     * active learning card, then an appropriate message is sent to the user.
     *
     * @param {WaterfallStepContext} step the waterfall step context
     * @returns {Promise<DialogTurnResult>} a promise resolving to the dialog turn result
     **/
    displayQnAResult(step) {
        const _super = Object.create(null, {
            runStep: { get: () => super.runStep }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            const reply = step.context.activity.text;
            if (reply == dialogOptions.qnaDialogResponseOptions.cardNoMatchText) {
                const activity = dialogOptions.qnaDialogResponseOptions.cardNoMatchResponse;
                yield step.context.sendActivity(activity !== null && activity !== void 0 ? activity : this.defaultCardNoMatchResponse);
                return step.endDialog();
            }
            const previousQnaId = step.activeDialog.state[this.previousQnAId];
            if (previousQnaId > 0) {
                return yield _super.runStep.call(this, step, 0, botbuilder_dialogs_1.DialogReason.beginCalled);
            }
            const response = step.result;
            if ((response === null || response === void 0 ? void 0 : response.length) > 0) {
                yield step.context.sendActivity(response[0].answer);
            }
            else {
                const activity = dialogOptions.qnaDialogResponseOptions.noAnswer;
                yield step.context.sendActivity(activity || this.defaultNoAnswer);
            }
            return yield step.endDialog(step.result);
        });
    }
    // Creates and returns an instance of the QnAMaker class used to query the knowledgebase.
    getQnAClient(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            const endpoint = {
                knowledgeBaseId: this.knowledgeBaseId.getValue(dc.state),
                endpointKey: this.endpointKey.getValue(dc.state),
                host: this.getHost(dc),
            };
            const logPersonalInformation = this.logPersonalInformation instanceof adaptive_expressions_1.BoolExpression
                ? this.logPersonalInformation.getValue(dc.state)
                : this.logPersonalInformation;
            return new _1.QnAMaker(endpoint, yield this.getQnAMakerOptions(dc), this.telemetryClient, logPersonalInformation);
        });
    }
    // Gets unmodified v5 API hostName or constructs v4 API hostName
    //
    // Example of a complete v5 API endpoint: "https://qnamaker-acom.azure.com/qnamaker/v5.0"
    //
    // Template literal to construct v4 API endpoint: `https://${ this.hostName }.azurewebsites.net/qnamaker`
    getHost(dc) {
        let host = this.hostname.getValue(dc.state);
        // If hostName includes 'qnamaker/v5', return the v5 API hostName.
        if (host.includes('qnamaker/v5')) {
            return host;
        }
        // V4 API logic
        // If the hostname contains all the necessary information, return it
        if (/^https:\/\/.*\.azurewebsites\.net\/qnamaker\/?/i.test(host)) {
            return host;
        }
        // Otherwise add required components
        if (!/https?:\/\//i.test(host)) {
            host = 'https://' + host;
        }
        // Web App Bots provisioned through the QnAMaker portal have "xxx.azurewebsites.net" in their
        // environment variables
        if (host.endsWith('.azurewebsites.net')) {
            // Add the remaining required path
            return host + '/qnamaker';
        }
        // If this.hostName is just the azurewebsite subdomain, finish the remaining V4 API behavior shipped in 4.8.0
        // e.g. `https://${ this.hostName }.azurewebsites.net/qnamaker`
        if (!host.endsWith('.azurewebsites.net/qnamaker')) {
            host = host + '.azurewebsites.net/qnamaker';
        }
        return host;
    }
}
exports.QnAMakerDialog = QnAMakerDialog;
QnAMakerDialog.$kind = 'Microsoft.QnAMakerDialog';
//# sourceMappingURL=qnaMakerDialog.js.map