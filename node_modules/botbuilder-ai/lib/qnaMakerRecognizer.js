"use strict";
/**
 * @module botbuilder-dialogs-adaptive
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QnAMakerRecognizer = void 0;
const adaptive_expressions_1 = require("adaptive-expressions");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const qnaMaker_1 = require("./qnaMaker");
const qnamaker_interfaces_1 = require("./qnamaker-interfaces");
const intentPrefix = 'intent=';
/**
 * A recognizer which uses QnAMaker KB to recognize intents.
 */
class QnAMakerRecognizer extends botbuilder_dialogs_1.Recognizer {
    /**
     * Initializes a new instance of `QnAMakerRecognizer`.
     *
     * @param {string} hostname Hostname of QnAMaker KB.
     * @param {string} knowledgeBaseId Id of QnAMaker KB.
     * @param {string} endpointKey Endpoint key of QnAMaker KB.
     */
    constructor(hostname, knowledgeBaseId, endpointKey) {
        super();
        /**
         * Number of results you want.
         */
        this.top = new adaptive_expressions_1.IntExpression(3);
        /**
         * Threshold for the results.
         */
        this.threshold = new adaptive_expressions_1.NumberExpression(0.3);
        /**
         * Desired RankerType.
         */
        this.rankerType = new adaptive_expressions_1.StringExpression(qnamaker_interfaces_1.RankerTypes.default);
        /**
         * Whether to include the dialog name metadata for QnA context.
         */
        this.includeDialogNameInMetadata = new adaptive_expressions_1.BoolExpression(true);
        /**
         * An expression to evaluate to set QnAId parameter.
         */
        this.qnaId = new adaptive_expressions_1.IntExpression(0);
        /**
         * The flag to indicate if personal information should be logged in telemetry.
         */
        this.logPersonalInformation = new adaptive_expressions_1.BoolExpression('=settings.telemetry.logPersonalInformation');
        if (hostname) {
            this.hostname = new adaptive_expressions_1.StringExpression(hostname);
        }
        if (knowledgeBaseId) {
            this.knowledgeBaseId = new adaptive_expressions_1.StringExpression(knowledgeBaseId);
        }
        if (endpointKey) {
            this.endpointKey = new adaptive_expressions_1.StringExpression(endpointKey);
        }
    }
    getConverter(property) {
        switch (property) {
            case 'knowledgeBaseId':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'hostname':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'endpointKey':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'top':
                return new adaptive_expressions_1.IntExpressionConverter();
            case 'threshold':
                return new adaptive_expressions_1.NumberExpressionConverter();
            case 'rankerType':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'includeDialogNameInMetadata':
                return new adaptive_expressions_1.BoolExpressionConverter();
            case 'metadata':
                return new adaptive_expressions_1.ArrayExpressionConverter();
            case 'context':
                return new adaptive_expressions_1.ObjectExpressionConverter();
            case 'qnaId':
                return new adaptive_expressions_1.IntExpressionConverter();
            case 'logPersonalInformation':
                return new adaptive_expressions_1.BoolExpressionConverter();
            default:
                return super.getConverter(property);
        }
    }
    /**
     * Gets results of the call to QnA maker KB.
     *
     * @param {DialogContext} dc Context object containing information for a single turn of coversation with a user.
     * @param {Activity} activity The incoming activity received from the user. The text value is used as the query to QnA Maker.
     * @param {object} telemetryProperties Additional properties to be logged to telemetry.
     * @param {object} telemetryMetrics Additional metrics to be logged to telemetry.
     * @returns {Promise<RecognizerResult>} A promise resolving to the recognizer result
     */
    recognize(dc, activity, telemetryProperties, telemetryMetrics) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return __awaiter(this, void 0, void 0, function* () {
            // identify matched intents
            const recognizerResult = {
                text: activity.text,
                intents: {},
                entities: {},
            };
            if (!activity.text) {
                recognizerResult.intents['None'] = { score: 1 };
                return recognizerResult;
            }
            const filters = [];
            if ((_a = this.includeDialogNameInMetadata) === null || _a === void 0 ? void 0 : _a.getValue(dc.state)) {
                const metadata = {
                    name: 'dialogName',
                    value: (_b = dc.activeDialog) === null || _b === void 0 ? void 0 : _b.id,
                };
                filters.push(metadata);
            }
            // if there is $qna.metadata set add to filters
            const externalMetadata = (_c = this.metadata) === null || _c === void 0 ? void 0 : _c.getValue(dc.state);
            if (externalMetadata) {
                filters.push(...externalMetadata);
            }
            // calling QnAMaker to get response
            const qnaMaker = this.getQnAMaker(dc);
            const qnaMakerOptions = {
                context: (_d = this.context) === null || _d === void 0 ? void 0 : _d.getValue(dc.state),
                scoreThreshold: (_e = this.threshold) === null || _e === void 0 ? void 0 : _e.getValue(dc.state),
                strictFilters: filters,
                top: (_f = this.top) === null || _f === void 0 ? void 0 : _f.getValue(dc.state),
                qnaId: (_g = this.qnaId) === null || _g === void 0 ? void 0 : _g.getValue(dc.state),
                rankerType: (_h = this.rankerType) === null || _h === void 0 ? void 0 : _h.getValue(dc.state),
                isTest: this.isTest,
                strictFiltersJoinOperator: this.strictFiltersJoinOperator,
            };
            const answers = yield qnaMaker.getAnswers(dc.context, qnaMakerOptions);
            if ((answers === null || answers === void 0 ? void 0 : answers.length) > 0) {
                let topAnswer;
                for (let i = 0; i < answers.length; i++) {
                    const answer = answers[i];
                    if (!topAnswer || answer.score > topAnswer.score) {
                        topAnswer = answer;
                    }
                }
                if (topAnswer.answer.trim().toLowerCase().startsWith(intentPrefix)) {
                    recognizerResult.intents[topAnswer.answer.trim().substr(intentPrefix.length).trim()] = {
                        score: topAnswer.score,
                    };
                }
                else {
                    recognizerResult.intents[QnAMakerRecognizer.qnaMatchIntent] = { score: topAnswer.score };
                }
                recognizerResult.entities['answer'] = [topAnswer.answer];
                recognizerResult.entities['$instance'] = {
                    answer: [
                        Object.assign(topAnswer, {
                            startIndex: 0,
                            endIndex: activity.text.length,
                        }),
                    ],
                };
                recognizerResult['answers'] = answers;
            }
            else {
                recognizerResult.intents['None'] = { score: 1 };
            }
            this.trackRecognizerResult(dc, 'QnAMakerRecognizerResult', this.fillRecognizerResultTelemetryProperties(recognizerResult, telemetryProperties), telemetryMetrics);
            return recognizerResult;
        });
    }
    /**
     * Gets an instance of `QnAMaker`.
     *
     * @param {DialogContext} dc The dialog context used to access state.
     * @returns {QnAMaker} A qna maker instance
     */
    getQnAMaker(dc) {
        var _a, _b, _c, _d, _e, _f;
        const { value: endpointKey, error } = (_b = (_a = this.endpointKey) === null || _a === void 0 ? void 0 : _a.tryGetValue(dc.state)) !== null && _b !== void 0 ? _b : {};
        if (!endpointKey || error) {
            throw new Error(`Unable to get a value for endpointKey from state. ${error}`);
        }
        const { value: host, error: error2 } = (_d = (_c = this.hostname) === null || _c === void 0 ? void 0 : _c.tryGetValue(dc.state)) !== null && _d !== void 0 ? _d : {};
        if (!host || error2) {
            throw new Error(`Unable to get a value for hostname from state. ${error2}`);
        }
        const { value: knowledgeBaseId, error: error3 } = (_f = (_e = this.knowledgeBaseId) === null || _e === void 0 ? void 0 : _e.tryGetValue(dc.state)) !== null && _f !== void 0 ? _f : {};
        if (!knowledgeBaseId || error3) {
            throw new Error(`Unable to get a value for knowledgeBaseId from state. ${error3}`);
        }
        const endpoint = { endpointKey, host, knowledgeBaseId };
        const logPersonalInfo = this.logPersonalInformation.getValue(dc.state);
        return new qnaMaker_1.QnAMaker(endpoint, {}, this.telemetryClient, logPersonalInfo);
    }
}
exports.QnAMakerRecognizer = QnAMakerRecognizer;
QnAMakerRecognizer.$kind = 'Microsoft.QnAMakerRecognizer';
QnAMakerRecognizer.qnaMatchIntent = 'QnAMatch';
//# sourceMappingURL=qnaMakerRecognizer.js.map