"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SettingsMemoryScope = void 0;
/**
 * @module botbuilder-dialogs
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const memoryScope_1 = require("./memoryScope");
const scopePath_1 = require("../scopePath");
const dialogTurnStateConstants_1 = require("../../dialogTurnStateConstants");
/**
 * The setting node.
 */
class Node {
    /**
     * Initializes a new instance of `Node`.
     *
     * @param {string} value Value of the node. If the node is not leaf, value represents the current path.
     */
    constructor(value) {
        this.value = value;
        /**
         * The child nodes of the node.
         */
        this.children = [];
    }
    /**
     * Indicates if the node is leaf node.
     *
     * @returns {boolean} If the node is leaf node or not.
     */
    isLeaf() {
        return this.children.length === 0;
    }
}
/**
 * SettingsMemoryScope maps "settings" -> dc.context.turnState['settings']
 */
class SettingsMemoryScope extends memoryScope_1.MemoryScope {
    /**
     * Initializes a new instance of the [SettingsMemoryScope](xref:botbuilder-dialogs.SettingsMemoryScope) class.
     */
    constructor() {
        super(scopePath_1.ScopePath.settings, false);
    }
    /**
     * Gets the backing memory for this scope.
     *
     * @param {DialogContext} dc The [DialogContext](xref:botbuilder-dialogs.DialogContext) object for this turn.
     * @returns {Record<string, ?>} The memory for the scope.
     */
    getMemory(dc) {
        var _a, _b;
        if (dc.context.turnState.has(scopePath_1.ScopePath.settings)) {
            return (_a = dc.context.turnState.get(scopePath_1.ScopePath.settings)) !== null && _a !== void 0 ? _a : {};
        }
        else {
            const configuration = (_b = dc.context.turnState.get(dialogTurnStateConstants_1.DialogTurnStateConstants.configuration)) !== null && _b !== void 0 ? _b : {};
            Object.entries(process.env).reduce((result, [key, value]) => {
                result[`${key}`] = value;
                return result;
            }, configuration);
            const settings = SettingsMemoryScope.loadSettings(configuration);
            dc.context.turnState.set(scopePath_1.ScopePath.settings, settings);
            return settings;
        }
    }
    /**
     * Build a dictionary view of configuration providers.
     *
     * @param {Record<string, string>} configuration The configuration that we are running with.
     * @returns {Record<string, ?>} Projected dictionary for settings.
     */
    static loadSettings(configuration) {
        const settings = {};
        if (configuration) {
            // load configuration into settings
            const root = this.convertFlattenSettingToNode(Object.entries(configuration));
            root.children.reduce((result, child) => {
                result[child.value] = this.convertNodeToObject(child);
                return result;
            }, settings);
        }
        return settings;
    }
    /**
     * Generate a node tree with the flatten settings.
     * For example:
     * {
     *   "array":["item1", "item2"],
     *   "object":{"array":["item1"], "2":"numberkey"}
     * }
     *
     * Would generate a flatten settings like:
     * array:0 item1
     * array:1 item2
     * object:array:0 item1
     * object:2 numberkey
     *
     * After Converting it from flatten settings into node tree, would get:
     *
     *                         null
     *                |                     |
     *              array                object
     *            |        |            |        |
     *           0          1        array        2
     *           |          |         |           |
     *         item1       item2      0        numberkey
     *                                |
     *                              item1
     * The result is a Tree.
     *
     * @param {Array<[string, string]>} kvs Configurations with key value pairs.
     * @returns {Node} The root node of the tree.
     */
    static convertFlattenSettingToNode(kvs) {
        const root = new Node();
        kvs.forEach(([key, value]) => {
            const keyChain = key.split(':');
            let currentNode = root;
            keyChain.forEach((item) => {
                const matchItem = currentNode.children.find((u) => (u === null || u === void 0 ? void 0 : u.value) === item);
                if (!matchItem) {
                    // Remove all the leaf children
                    currentNode.children = currentNode.children.filter((u) => u.children.length !== 0);
                    // Append new child into current node
                    const node = new Node(item);
                    currentNode.children.push(node);
                    currentNode = node;
                }
                else {
                    currentNode = matchItem;
                }
            });
            currentNode.children.push(new Node(value));
        });
        return root;
    }
    static convertNodeToObject(node) {
        if (!node.children.length) {
            return {};
        }
        // If the child is leaf node, return its value directly.
        if (node.children.length === 1 && node.children[0].isLeaf()) {
            return node.children[0].value;
        }
        // check if all the children are number format.
        let pureNumberIndex = true;
        const indexArray = [];
        let indexMax = -1;
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[Number(i)];
            if (/^-?\d+$/.test(child.value)) {
                const num = parseInt(child.value, 10);
                if (!isNaN(num) && num >= 0) {
                    indexArray.push(num);
                    if (num > indexMax) {
                        indexMax = num;
                    }
                    continue;
                }
            }
            pureNumberIndex = false;
            break;
        }
        if (pureNumberIndex) {
            // all children are int numbers, treat it as array.
            const listResult = new Array(indexMax + 1);
            node.children.forEach((child, index) => {
                listResult[indexArray[Number(index)]] = this.convertNodeToObject(child);
            });
            return listResult;
        }
        // Convert all child into dictionary
        return node.children.reduce((result, child) => {
            result[child.value] = this.convertNodeToObject(child);
            return result;
        }, {});
    }
}
exports.SettingsMemoryScope = SettingsMemoryScope;
//# sourceMappingURL=settingsMemoryScope.js.map