"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Recognizer = void 0;
/**
 * @module botbuilder-dialogs-adaptive
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const botbuilder_core_1 = require("botbuilder-core");
const configurable_1 = require("./configurable");
const dialogTurnStateConstants_1 = require("./dialogTurnStateConstants");
class Recognizer extends configurable_1.Configurable {
    constructor() {
        super(...arguments);
        /**
         * The telemetry client for logging events.
         * Default this to the NullTelemetryClient, which does nothing.
         */
        this.telemetryClient = new botbuilder_core_1.NullTelemetryClient();
    }
    /**
     * To recognize intents and entities in a users utterance.
     *
     * @param {DialogContext} dialogContext Dialog Context.
     * @param {Partial<Activity>} activity Activity.
     * @param {Record<string, string>} telemetryProperties Additional properties to be logged to telemetry with event.
     * @param {Record<string, number>} telemetryMetrics Additional metrics to be logged to telemetry with event.
     * @returns {Promise<RecognizerResult>} Recognized result.
     */
    recognize(dialogContext, activity, telemetryProperties, telemetryMetrics) {
        throw new Error('Please implement recognize function.');
    }
    /**
     * Creates choose intent result in the case that there is conflicting or ambigious signals from the recognizers.
     *
     * @param {Record<string, RecognizerResult>} recognizerResults A group of recognizer results.
     * @returns {RecognizerResult} Recognizer result which is ChooseIntent.
     */
    createChooseIntentResult(recognizerResults) {
        let text;
        const candidates = Object.entries(recognizerResults).reduce((candidates, [key, result]) => {
            text = result.text;
            const { intent, score } = botbuilder_core_1.getTopScoringIntent(result);
            if (intent !== 'None') {
                candidates.push({
                    id: key,
                    intent,
                    score,
                    result,
                });
            }
            return candidates;
        }, []);
        if (candidates.length) {
            // return `ChooseIntent` with candidates array.
            const recognizerResult = {
                text,
                intents: { ChooseIntent: { score: 1.0 } },
                candidates,
            };
            return recognizerResult;
        }
        // just return a `None` intent.
        const recognizerResult = {
            text,
            intents: { None: { score: 1.0 } },
        };
        return recognizerResult;
    }
    /**
     * Uses the RecognizerResult to create a list of propeties to be included when tracking the result in telemetry.
     * @param recognizerResult Recognizer Result.
     * @param telemetryProperties A list of properties to append or override the properties created using the RecognizerResult.
     * @param dialogContext Dialog Context.
     * @returns A dictionary that can be included when calling the TrackEvent method on the TelemetryClient.
     */
    fillRecognizerResultTelemetryProperties(recognizerResult, telemetryProperties, dialogContext) {
        const { intent, score } = botbuilder_core_1.getTopScoringIntent(recognizerResult);
        const properties = {
            Text: recognizerResult.text,
            AlteredText: recognizerResult.alteredText,
            TopIntent: Object.entries(recognizerResult.intents).length > 0 ? intent : undefined,
            TopIntentScore: Object.entries(recognizerResult.intents).length > 0 ? score.toString() : undefined,
            Intents: Object.entries(recognizerResult.intents).length > 0
                ? JSON.stringify(recognizerResult.intents)
                : undefined,
            Entities: recognizerResult.entities ? JSON.stringify(recognizerResult.entities) : undefined,
            AdditionalProperties: this.stringifyAdditionalPropertiesOfRecognizerResult(recognizerResult),
        };
        // Additional Properties can override "stock" properties.
        if (telemetryProperties) {
            return Object.assign({}, properties, telemetryProperties);
        }
        return properties;
    }
    stringifyAdditionalPropertiesOfRecognizerResult(recognizerResult) {
        const generalProperties = new Set(['text', 'alteredText', 'intents', 'entities']);
        const additionalProperties = {};
        for (const key in recognizerResult) {
            if (!generalProperties.has(key)) {
                additionalProperties[key] = recognizerResult[key];
            }
        }
        return Object.keys(additionalProperties).length > 0 ? JSON.stringify(additionalProperties) : undefined;
    }
    trackRecognizerResult(dialogContext, eventName, telemetryProperties, telemetryMetrics) {
        if (this.telemetryClient instanceof botbuilder_core_1.NullTelemetryClient) {
            const turnStateTelemetryClient = dialogContext.context.turnState.get(dialogTurnStateConstants_1.DialogTurnStateConstants.telemetryClient);
            this.telemetryClient = turnStateTelemetryClient || this.telemetryClient;
        }
        this.telemetryClient.trackEvent({
            name: eventName,
            properties: telemetryProperties,
            metrics: telemetryMetrics,
        });
    }
}
exports.Recognizer = Recognizer;
//# sourceMappingURL=recognizer.js.map